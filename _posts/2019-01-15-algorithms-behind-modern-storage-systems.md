---
layout: post
title: "现代存储系统背后的算法"
date: 2019-01-15 12:00:00
categories: storage
---

# 摘要

应用处理的数据在持续增长，扩展存储系统更具备挑战性。每个数据库系统都有自己的折中，理解这点非常重要，帮助从很多可选项中选择正确的一个。

每一个应用就读/写负载均衡、一致性需求、延迟、访问模式而言都不尽相同。熟悉数据库和内部存储可以帮助做出架构决策，解释为什么一个系统表现出特定方式，帮助排除出现的故障问题，帮助为负载调优。

从各个方面优化一个系统是不可能的。在理想情况下，存在一个保证了最佳读写性能却没有额外成本的数据结构，但是实际中并不可行。

本文介绍了两种大部分现代数据库使用的存储系统设计方法——读优化的 B 树和写优化的 LSM 树（Log-structured merge），描述了它们的使用场景和利弊。

# B 树

B 树是一个流行的读优化的索引数据结构，是二叉树的推广。B 树有很多变体，被众多数据库（包括 MySQL InnoDB 和 PostgreSQL）甚至文件系统（HFS+，ext4 中的 HTrees）使用。B 树中的 B 代表 Bayer，原始数据结构的作者。或者波音（Boeing），当时作者工作的公司。

二叉树中每个节点有两个子节点（左子节点和右子节点），左子树比当前节点小，右子树比当前节点大。为了使树的高度最小，需要平衡二叉树：当一个随机排序的节点加入时，树的一侧会比另一侧高。

一种平衡二叉树的方法是旋转：重排节点，把更长子树的父节点下推，并把它的孩子上拉。如下图。

二叉树在内存数据中非常有用。然而受限于其平衡和低扇出（low fanout，每个节点最多两个指针），并不能推广到磁盘中。B 树允许每个节点拥有更多的指针，并且通过节点大小和页大小（例如 4KB）的匹配，和块设备工作的非常好。一些当前的实现中使用了更大的节点大小，跨越了多个页。

B 树有如下特性：

- **排序**。顺序扫描和简化了查找。
- **自平衡**。插入和删除操作都不需要平衡操作：当一个 B 树节点满了之后，会分裂为两个；当相邻节点的占用率低于一个阈值时，会发生合并。这意味着树叶和根节点距离相同，在查找中需要相同的步数。
- **对数（log）时间查找**。B 树是对查找时间重要的数据库索引的一个好的选择。
- **可变性**。插入、更新、删除（后续分裂和合并）在磁盘上原地（in place）操作。为了使原地更新可行，一部分空间消耗是必须的。B 树可以组织为一个聚类索引——真实数据存储在叶节点上，或者一个堆文件——非聚类 B 树索引。

本文讨论了 B+树，一个 B 树的现代变体，在数据库存储中广泛使用。B+树和原始 B 树不同在于：B+树有一层附加的连接叶节点存储值，这些值不能存储在内部节点上。

# B 树

B 树的组成如图 2. B 树有如下节点类型：根节点、内部节点、叶节点。根节点没有父节点；内部节点有父节点和子节点；叶节点持有数据，没有子节点。图 2 中的 B 树的分支因子是 4（4 个指针，内部节点有 3 个键，叶节点有 4 个键/值对）。
B 树特征如下：

- **分支因子**。指向子节点的脂针数 N。除了这些指针外，根节点和内部节点持有 N-1 个键（key）。
- **占用率**。节点当前指向子节点的指针和最大可用指针之比。例如，如果树的分支因子是 N，节点当前有 N/2 个指针，占有率是 50%。
- **高度**。B 树的层数，指示了查找操作中需要遍历的指针个数。

每个非叶节点

# 作者

- ALEX PETROV
- 译自
