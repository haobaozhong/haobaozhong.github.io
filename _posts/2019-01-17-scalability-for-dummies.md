---
layout: post
title: "可扩展性入门"
date: 2019-01-17 12:00:00
categories: scalability
---

# 怎么扩展一个 web 服务？

## 复制

一个可扩展的 web 服务在一个负载均衡后面。负载均衡把负载（用户请求）分发到应用服务器集群上。这意味着比如一个用户请求服务时，第一个请求可能被服务器 2 处理，第二个被服务器 9 处理，第三个可能又被服务器 2 处理。

同一个请求不管从哪个服务器获得服务，需要返回相同的响应。这是可扩展性的第一个准则：**每个服务器包含相同的代码，不存储用户相关的数据和状态在本地**。比如不把会话 session 存在本地磁盘或内存中。

会话 session 需要存在一个中心数据存储中，可以被所有应用服务器访问。存储可以是一个外部的数据库或外部的缓存，比如 Redis。缓存通常要比数据库有更好的性能。“外部”是指数据存储不在应用服务器上，而是在应用服务器周边的数据中心。

多个服务器怎么部署呢？你需要保证代码变化部署到所有的服务器上，而不是有些服务器还运行旧的代码。所幸 Docker/Kubernetes 等容器化实践已经较好的解决了该问题。通过把会话 session“外包”出去，并且所有服务器运行同一套代码，你可以为你的应用创建一个镜像，并复制任意副本到云上。

## 数据库

通过复制后，应用可以通过横向扩展来服务任意多的并发请求。但是某一天数据库可能成为瓶颈，比如 MySQL，这时不再能简单通过增加服务器来扩展。你可以选择两种方案：

1. 继续使用 MySQL。DBA（数据库管理员）进行主-从复制和读写分离（从服务负责读，主服务负责写），并且为主服务增加内存。下一步进行分片（sharding）、去规范化（denormalization）、和 SQL 调优（SQL tuning）。后续的扩展的代价会越来越高，最好在数据规模比较小时就考虑方案 2.
2. 从一开始就去规范化。不再直接在查询中使用连接（join）。你可以继续使用 MySQL，但是以 NoSQL 的方式，或者可以切换到典型的更简单的 NoSQL 数据库，比如 MongoDB。此时在应用代码中进行连接操作。进早执行这一步可以避免未来更多的变化。即便解决来数据库扩展问题，某一天还是可能会越来越慢，这时你就需要用到缓存。

## 缓存

这里的“缓存”是指内存缓存，比如 Memcached 或 Redis。不要使用基于文件的缓存，那将会使应用复制和自动扩展变得很困难。
缓存仅仅是位于应用和数据存储之间的键-值存储。当应用需要数据时，先尝试从缓存中获取。仅仅当缓存中没有所需数据时，才需要从主要数据源获取数据。为什么这么做呢？因为缓存非常快。缓存把数据放在内存中，请求可以得到尽快处理。例如，一台服务器上的 Redis 每秒可以处理成百上千个读请求，写操作，尤其是增量写操作也非常快。数据库和缓存配合工作的非常好。
缓存数据有两个模式，一个关于旧数据，一个关于新数据：

1. 缓存数据库查询
   这非常常见。当你执行一个数据库查询时，将查询结果缓存起来。查询可以作为散列的缓存键（key）。下次执行相同查询时，可以先从缓存中获取。这个模式的主要问题是过期问题。当你缓存了一个复杂的查询时，变得很难删除。当数据中一小部分（比如一列）发生变化时，你需要删除包含这列的所有缓存。
2. 缓存对象
   这是推荐使用的模式。把数据看作对象，和你在代码中一样（类、对象等）。把数据库中的数据组装的对象或数据集缓存起来。比如你有一个`Product`的类，有一个属性是`data`，是一个包含价格、文本、图像和客户评论的数组。`data`属性需要多个方法执行数据库查询，较多的关联使得很难直接缓存。这时可以在完成查询组装`data`数组后，直接把`data`数组或`Product`对象缓存起来。发生变化时，可以更新缓存，使得代码更易懂，更具有逻辑性。
   更好的是，可以利用异步处理。可以用多个异步服务来组装对象，应用直接使用最新的缓存对象，甚至不再需要直接访问数据库。

适合缓存的对象比如：
用户会话 session（不再使用数据库）
完整渲染的博客
活动流
用户-朋友关系

缓存理解和实现上都比较简单，性能提升非常显著。和 Memcached 相比，个人更偏好 Redis。因为 Redis 提供了持久化、内置数据结构等特性。巧妙使用 Redis 甚至可以代替数据库。

## 异步

1. 模式 1
   预先处理耗时的工作，降低请求延迟。比如预先把动态内容网页转化成静态的 HTML 文件。

2. 模式 2
   异步处理任务。比如典型的异步工作流：
   用户访问网站并启动了一项耗时的计算任务，可能需要几分钟才能完成。这时网站发送一个任务到任务队列中，并立即告诉前端用户，你的任务已经在处理中，请继续访问。一组工作节点持续从任务队列中接受新任务。当任务完成时，发送一个任务已经完成的信号。前端收到信号时通知用户已完成。
   推荐 RabbitMQ。也可以使用 ActiveMQ 或 Redis 消息。基本思想是一个工作节点处理一个任务队列。

## 作者

- 译自 [http://www.lecloud.net/tagged/scalability](http://www.lecloud.net/tagged/scalability)
- 作者 Sebastian Kreutzberger
